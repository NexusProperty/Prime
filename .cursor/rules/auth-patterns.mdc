---
description: Authentication Patterns - Supabase Auth + Next.js App Router
globs: "**/auth/**", "**/Auth*", "**/middleware*", "**/app/(auth)/**"
alwaysApply: false
---

# Authentication Patterns — United Trades (Supabase Auth + Next.js App Router)

> This project uses **Supabase Auth** with **Next.js 15 App Router**. Authentication uses `@supabase/ssr` for cookie-based session management. Each of the 3 sites (Prime Electrical, AKF Construction, CleanJet) shares the same Supabase Auth project.

---

## Supabase Auth Setup (App Router)

### Middleware (Root of each site)
```typescript
// middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) =>
            request.cookies.set(name, value)
          )
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  // Protect admin routes
  if (request.nextUrl.pathname.startsWith('/admin') && !user) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|api/leads).*)'],
}
```

---

## Auth Flow (App Router)

### Login Page Pattern
```typescript
// src/app/(auth)/login/page.tsx
'use client'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'

export default function LoginPage() {
  const router = useRouter()
  const supabase = createClient()

  async function handleLogin(formData: FormData) {
    const { error } = await supabase.auth.signInWithPassword({
      email: formData.get('email') as string,
      password: formData.get('password') as string,
    })

    if (error) {
      // Handle error state
      return
    }

    router.push('/admin')
    router.refresh()  // IMPORTANT: refresh to update server components
  }

  return (
    <form action={handleLogin}>
      {/* form fields */}
    </form>
  )
}
```

### Get Current User in Server Component
```typescript
// In any server component or layout
import { createClient } from '@/lib/supabase/server'

export default async function AdminLayout({ children }) {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    redirect('/login')
  }

  return <>{children}</>
}
```

---

## Auth Rules (Critical)

```typescript
// ✅ CORRECT — use getUser() not getSession() for server-side auth
const { data: { user } } = await supabase.auth.getUser()

// ❌ WRONG — getSession() trusts JWT without server validation (security risk)
const { data: { session } } = await supabase.auth.getSession()
```

### Never Trust Client-Side Auth for Protected Data
```typescript
// ✅ CORRECT — Row Level Security (RLS) in Supabase enforces access
// Even if client sends wrong user ID, RLS prevents unauthorized access

// ❌ WRONG — never check auth only on client side for sensitive operations
if (user.id === requestedId) { // Client can lie about user.id!
  return sensitiveData
}
```

---

## Row Level Security (RLS)

All Supabase tables MUST have RLS enabled. Standard policies for the leads table:

```sql
-- Enable RLS
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;

-- Allow service role to do everything (for Make.com webhook)
CREATE POLICY "Service role full access" ON leads
  FOR ALL USING (auth.role() = 'service_role');

-- Allow authenticated users (admins) to read all leads
CREATE POLICY "Admins can read leads" ON leads
  FOR SELECT USING (auth.role() = 'authenticated');
```

---

## Auth State for E2E Tests

```typescript
// In admin layout or auth context — expose for E2E tests only
useEffect(() => {
  if (process.env.NODE_ENV !== 'production') {
    (window as any).__AUTH_STATE__ = {
      isLoading,
      isAuthenticated: !!user,
      isReady: !isLoading && !!user,
      userId: user?.id,
    }
  }
}, [isLoading, user])
```

---

## Auth Race Conditions (App Router Specific)

### Always Call router.refresh() After Sign-In
```typescript
// ✅ CORRECT — refresh updates server components with new session
await supabase.auth.signInWithPassword({ email, password })
router.push('/admin')
router.refresh()  // Without this, server layouts still see old session

// ❌ WRONG — navigation without refresh = server still sees unauthenticated
router.push('/admin')
```

### Cookie Propagation Delay
After sign-out, there's a brief window where cookies are clearing. If redirecting immediately after signOut, always use full page reload:
```typescript
await supabase.auth.signOut()
window.location.href = '/login'  // Full reload, not router.push()
```

---

## Checklist

- [ ] Middleware handles session refresh on every request
- [ ] `getUser()` used (not `getSession()`) for server-side auth checks
- [ ] RLS enabled on all Supabase tables
- [ ] `router.refresh()` called after sign-in
- [ ] `window.location.href` (not `router.push`) after sign-out
- [ ] Admin routes protected in both middleware AND layout
