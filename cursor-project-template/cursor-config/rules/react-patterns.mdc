---
description: React Component Patterns and Anti-Patterns
globs: "**/*.tsx", "**/*.ts"
alwaysApply: false
---

# React Component Patterns

> These rules prevent common bugs discovered during production development and testing. They are framework-agnostic for React projects ‚Äî customize the project-specific examples below.

## üö® CRITICAL: React Hooks Order

### Rule 1: Never Return Before Hooks

All hooks must be called before any conditional returns. React requires hooks to be called in the same order on every render.

```typescript
// ‚ùå ANTI-PATTERN: Conditional return before hooks (causes crash!)
function MyComponent() {
  const { user } = useAuth();
  
  // THIS CRASHES! useState not called for non-admins
  if (user?.role !== 'admin') {
    return <Navigate to="/dashboard" />;
  }
  
  const [state, setState] = useState(false); // Hook order violation!
  
  return <div>...</div>;
}

// ‚úÖ CORRECT: All hooks before conditional returns
function MyComponent() {
  const { user } = useAuth();
  const [state, setState] = useState(false); // All hooks first
  
  // Now safe to return early
  if (user?.role !== 'admin') {
    return <Navigate to="/dashboard" />;
  }
  
  return <div>...</div>;
}
```

**Error this prevents:**
```
Rendered more hooks than during the previous render.
```

## üîÑ Loading State Management

### Rule 2: Always Resolve Loading States

Async operations should ALWAYS resolve `isLoading` state, even on error. Use `finally` blocks.

```typescript
// ‚ùå ANTI-PATTERN: Loading state can hang forever
async function fetchData() {
  setIsLoading(true);
  try {
    const data = await fetch('/api/data');
    setData(data);
    setIsLoading(false); // Not called if fetch throws!
  } catch (error) {
    setError(error); // isLoading still true!
  }
}

// ‚úÖ CORRECT: Loading state always resolves
async function fetchData() {
  setIsLoading(true);
  try {
    const data = await fetch('/api/data');
    setData(data);
  } catch (error) {
    setError(error);
  } finally {
    setIsLoading(false); // ALWAYS called
  }
}
```

### Rule 3: Add Timeout Protection to Async Operations

Prevent infinite hangs with timeout protection.

```typescript
// ‚úÖ CORRECT: Timeout protection
const fetchWithTimeout = async <T>(
  promise: Promise<T>,
  timeoutMs: number,
  fallback: T
): Promise<T> => {
  const timeoutPromise = new Promise<T>((resolve) => {
    setTimeout(() => {
      console.warn(`Operation timed out after ${timeoutMs}ms`);
      resolve(fallback);
    }, timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]);
};
```

## üéØ Component Design

### Rule 4: Add data-testid to Critical Elements

Add `data-testid` attributes to elements that tests need to find reliably.

```typescript
// ‚ùå ANTI-PATTERN: No stable selectors
<div className="dashboard-container">
  <h1>Welcome Back</h1>
</div>

// ‚úÖ CORRECT: Stable test selectors
<div data-testid="main-dashboard" className="dashboard-container">
  <h1 data-testid="welcome-heading">Welcome Back</h1>
</div>
```

### Rule 5: Handle Missing Data Gracefully

Components should render appropriately when data is loading, missing, or errored.

```typescript
// ‚ùå ANTI-PATTERN: Assumes data exists
function UserCard({ profile }) {
  return <div>{profile.name}</div>; // Crashes if profile is null!
}

// ‚úÖ CORRECT: Handle all states
function UserCard({ profile, isLoading, error }) {
  if (isLoading) return <Skeleton className="h-20 w-full" />;
  if (error) return <Alert variant="destructive">Failed to load</Alert>;
  if (!profile) return <p className="text-muted-foreground">No data</p>;
  return <div>{profile.name}</div>;
}
```

## üîê Authentication Patterns

### Rule 6: Use a Guard Component for Auth-Required Pages

All authenticated routes must use your auth guard component.

```typescript
// ‚ùå ANTI-PATTERN: No route protection
<Route path="/dashboard" element={<DashboardPage />} />

// ‚úÖ CORRECT: Protected route
<Route 
  path="/dashboard" 
  element={
    <AuthGuard>
      <DashboardPage />
    </AuthGuard>
  } 
/>
```

> **Customize:** Replace `AuthGuard` with your project's component name.

### Rule 7: Expose Auth State for Testing

In development/test environments, expose auth state on window for E2E tests.

```typescript
useEffect(() => {
  if (process.env.NODE_ENV !== 'production') {
    (window as any).__AUTH_STATE__ = {
      isLoading,
      isAuthenticated,
      isReady: !isLoading && isAuthenticated,
    };
  }
}, [isLoading, isAuthenticated]);
```

## üé® UI Component Patterns

### Rule 8: Use Radix UI Correctly (if applicable)

```typescript
// ‚ùå ANTI-PATTERN: Expecting native select behavior
<Select value={value} onChange={handleChange}> // No onChange prop!

// ‚úÖ CORRECT: Radix Select pattern
<Select value={value} onValueChange={handleChange}>
  <SelectTrigger>
    <SelectValue placeholder="Select option" />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="option1">Option 1</SelectItem>
  </SelectContent>
</Select>
```

### Rule 9: Form Input Types Matter

```typescript
// ‚úÖ CORRECT: Appropriate input type
<Input type="number" value={price} min={0} step={1} />
```

## üîÑ State Management

### Rule 10: Avoid Prop Drilling for Global State

Use context for state needed across many components.

### Rule 11: Prefer React Query for Server State

Use React Query for data fetching, not `useState + useEffect`.

## ‚ö†Ô∏è JavaScript Safety

### Rule 12: IIFE Safety ‚Äî Always Prefix with `void` or `;`

When using an IIFE after another statement, JavaScript's Automatic Semicolon Insertion (ASI) can chain the IIFE as a function call on the previous expression.

```typescript
// ‚ùå ANTI-PATTERN: ASI interprets this as someFunction()(...) ‚Üí TypeError
const sub = someObservable.subscribe(callback)
(async () => { /* side effect */ })()

// ‚úÖ CORRECT: Prefix with void (preferred)
const sub = someObservable.subscribe(callback)
void (async () => { /* side effect */ })()
```

### Rule 13: data-testid Must Be Unique Per Viewport

Every `data-testid` value MUST resolve to exactly ONE visible element at any given time. If the same action appears in multiple viewport layouts, use suffixed testids.

```typescript
// ‚ùå ANTI-PATTERN: Duplicate testid
<Button data-testid="nav-logout" /> {/* mobile header */}
<Button data-testid="nav-logout" /> {/* desktop sidebar */}

// ‚úÖ CORRECT: Unique per viewport
<Button data-testid="nav-logout-mobile" />
<Button data-testid="nav-logout" />
```

### Rule 14: Route-Dependent Behavior Must Check Route First

```typescript
// ‚ùå ANTI-PATTERN: Only checks role
const persona = resolveFromRole(user?.role);

// ‚úÖ CORRECT: Route first, then role
const persona = isMarketingPage(pathname)
  ? 'default'
  : resolveFromRole(user?.role);
```

## üìã Component Checklist

Before submitting a new component, verify:

- [ ] All hooks are called before any conditional returns
- [ ] Loading states always resolve (use `finally`)
- [ ] Has `data-testid` on critical elements
- [ ] `data-testid` values are unique across viewports
- [ ] Handles loading, error, and empty states
- [ ] Uses auth guard if auth-required
- [ ] Uses appropriate input types
- [ ] No bare IIFE after function calls ‚Äî use `void` prefix
